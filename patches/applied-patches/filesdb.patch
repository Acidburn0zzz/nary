diff --git i/inary/db/filesdb.py w/inary/db/filesdb.py
index df7b0c7e..3b0b789d 100644
--- i/inary/db/filesdb.py
+++ w/inary/db/filesdb.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 #
-# Copyright (C) 2005 - 2007, TUBITAK/UEKAE
+# Copyright (C) 2016 - 2018, Suleyman POYRAZ (Zaryob)
 #
 # This program is free software; you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the Free
@@ -12,17 +12,21 @@
 
 import os
 import re
-import shelve
 import hashlib
+try:
+   import shelve
+except ImportError:
+   raise Exception(_("FilesDB broken: Shelve module not imported."))
 
-import inary
-import inary.context as ctx
-import inary.db.lazydb as lazydb
 
 import gettext
 __trans = gettext.translation('inary', fallback=True)
 _ = __trans.gettext
 
+import inary
+import inary.db.lazydb as lazydb
+import inary.context as ctx
+
 # FIXME:
 # We could traverse through files.xml files of the packages to find the path and
 # the package - a linear search - as some well known package managers do. But the current 
@@ -30,22 +34,31 @@ _ = __trans.gettext
 # So currently filesdb is the only db and we cant still get rid of rebuild-db :/
 
 class FilesDB(lazydb.LazyDB):
+    def __init__(self):
+        self.filesdb={}
+        self.filesdb_path = os.path.join(ctx.config.info_dir(), ctx.const.files_db)
+        #if not [f for f in os.listdir(self.filesdb_path) if f.endswith('.db')]:
+        #    if ctx.scom: self.destroy()
+        #    self.create_filesdb()
 
-    def init(self):
-        self.filesdb = {}
-        self.__check_filesdb()
-        self.create_filesdb
+        if isinstance(self.filesdb, shelve.DbfilenameShelf):
+            return
 
-    def has_file(self, path):
-        return hashlib.md5(path.encode('utf-8')).digest() in self.filesdb
+        if not os.path.exists(self.filesdb_path):
+            flag = "n"
+        elif os.access(self.filesdb_path, os.W_OK):
+            flag = "w"
+        else:
+            flag = "r"
 
-    def get_file(self, path):
-        return self.filesdb[hashlib.md5(path.encode('utf-8')).digest()], path
+        self.filesdb = shelve.open(self.filesdb_path, flag=flag)
+
+    def __del__(self):
+        self.close()
 
     def create_filesdb(self):
         ctx.ui.info(inary.util.colorize(_('Creating files database...'), 'blue'))
         installdb = inary.db.installdb.InstallDB()
-
         for pkg in installdb.list_installed():
             ctx.ui.info(inary.util.colorize(_('  ---> Adding \'{}\' to db... '), 'purple').format(pkg), noln= True)
             files = installdb.get_files(pkg)
@@ -53,6 +66,14 @@ class FilesDB(lazydb.LazyDB):
             ctx.ui.info(inary.util.colorize(_('OK.'), 'backgroundmagenta'))
         ctx.ui.info(inary.util.colorize(_('Added files database...'), 'blue'))
 
+    def has_file(self, path):
+        key= str(hashlib.md5(path.encode('utf-8')).digest())
+        return key in self.filesdb
+
+    def get_file(self, path):
+        key= str(hashlib.md5(path.encode('utf-8')).digest())
+        return self.filesdb[key], path
+
     def search_file(self, term):
         if self.has_file(term):
             pkg, path = self.get_file(term)
@@ -68,42 +89,24 @@ class FilesDB(lazydb.LazyDB):
         return found
 
     def add_files(self, pkg, files):
-
-        self.__check_filesdb()
-
         for f in files.list:
-            self.filesdb[hashlib.md5(f.path.encode('utf-8')).digest()] = pkg
+            key= str(hashlib.md5(f.path.encode('utf-8')).digest())
+            value= str(pkg.encode('utf-8'))
+            self.filesdb[key] = value
 
     def remove_files(self, files):
         for f in files:
-            if hashlib.md5(f.path).digest() in self.filesdb:
-                del self.filesdb[hashlib.md5(f.path.encode('utf-8')).digest()]
+            key= str(hashlib.md5(f.path.encode('utf-8')).digest())
+            if key in self.filesdb:
+                del self.filesdb[key]
 
     def destroy(self):
-        files_db = os.path.join(ctx.config.info_dir(), ctx.const.files_db)
+        self.filesdb_path = os.path.join(ctx.config.info_dir(), ctx.const.files_db)
         ctx.ui.info(inary.util.colorize(_('Cleaning files database folder...  '), 'green'), noln=True)
-        for f in os.listdir(files_db):
-            os.unlink(files_db)
-            ctx.ui.info(inary.util.colorize(_('done.'), 'green'))
-
+        if os.path.exists(self.filesdb_path):
+            os.unlink(self.filesdb_path)
+        ctx.ui.info(inary.util.colorize(_('done.'), 'green'))
 
     def close(self):
         if isinstance(self.filesdb, shelve.DbfilenameShelf):
             self.filesdb.close()
-
-    def __check_filesdb(self):
-        if isinstance(self.filesdb, shelve.DbfilenameShelf):
-            return
-
-        files_db = os.path.join(ctx.config.info_dir(), ctx.const.files_db)
-
-        if not os.path.exists(files_db):
-            flag = "n"
-        elif os.access(files_db, os.W_OK):
-            flag = "w"
-        else:
-            flag = "r"
-
-        flag ="n"
-
-        self.filesdb = shelve.open(files_db, flag=flag)
diff --git i/inary/db/filesldb.py w/inary/db/filesldb.py
deleted file mode 100644
index b8cd5733..00000000
--- i/inary/db/filesldb.py
+++ /dev/null
@@ -1,82 +0,0 @@
-# -*- coding: utf-8 -*-
-#
-# Copyright (C) 2016 - 2018, Suleyman POYRAZ (Zaryob)
-#
-# This program is free software; you can redistribute it and/or modify it under
-# the terms of the GNU General Public License as published by the Free
-# Software Foundation; either version 2 of the License, or (at your option)
-# any later version.
-#
-# Please read the COPYING file.
-#
-
-import os
-import re
-import hashlib
-
-import gettext
-__trans = gettext.translation('inary', fallback=True)
-_ = __trans.gettext
-
-import inary
-import inary.context as ctx
-
-class FilesLDB():
-    def __init__(self):
-        try:
-            import plyvel
-        except ImportError:
-            raise ImportError(_("LevelDB not found! Please install LevelDB and plyvel!"))
-        self.files_ldb_path = os.path.join(ctx.config.info_dir(), ctx.const.files_ldb)
-        self.filesdb = plyvel.DB(self.files_ldb_path, create_if_missing=True)
-        if not [f for f in os.listdir(self.files_ldb_path) if f.endswith('.ldb')]:
-            if ctx.scom: self.destroy()
-            self.create_filesdb()
-
-    def __del__(self):
-        self.close()
-
-    def create_filesdb(self):
-        ctx.ui.info(inary.util.colorize(_('Creating files database...'), 'blue'))
-        installdb = inary.db.installdb.InstallDB()
-        for pkg in installdb.list_installed():
-            #ctx.ui.info(inary.util.colorize(_('  ---> Adding \'{}\' to db... '), 'purple')Â¿format(pkg), noln= True)
-            files = installdb.get_files(pkg)
-            self.add_files(pkg, files)
-            #ctx.ui.info(inary.util.colorize(_('OK.'), 'backgroundmagenta'))
-        ctx.ui.info(inary.util.colorize(_('Added files database...'), 'blue'))
-
-    def get_file(self, path):
-        return self.filesdb.get(hashlib.md5(path.encode('utf-8')).digest()), path
-
-    def search_file(self, term):
-        pkg, path = self.get_file(term)
-        if pkg:
-            return [(pkg,[path])]
-
-        installdb = inary.db.installdb.InstallDB()
-        found = []
-        for pkg in installdb.list_installed():
-            files_xml = open(os.path.join(installdb.package_path(pkg), ctx.const.files_xml)).read()
-            paths = re.compile('<Path>(.*?{}.*?)</Path>'.format(re.escape(term)), re.I).findall(files_xml)
-            if paths:
-                found.append((pkg, paths))
-        return found
-
-    def add_files(self, pkg, files):
-        for f in files.list:
-            key=bytes(hashlib.md5(f.path.encode('utf-8')).digest())
-            value= bytes(pkg.encode('utf-8'))
-            self.filesdb.put(key=key, value=value)
-
-    def remove_files(self, files):
-        for f in files:
-            self.filesdb.delete(bytes(hashlib.md5(f.path.encode('utf-8')).digest()))
-
-    def destroy(self):
-        ctx.ui.info(inary.util.colorize(_('Cleaning files database folder... '), 'green'), noln=True)
-        for f in os.listdir(self.files_ldb_path): os.unlink(os.path.join(self.files_ldb_path, f))
-        ctx.ui.info(inary.util.colorize(_('done.'), 'green'))
-
-    def close(self):
-        if not self.filesdb.closed: self.filesdb.close()
diff --git i/inary/reactor.py w/inary/reactor.py
index d876231d..b4154065 100644
--- i/inary/reactor.py
+++ w/inary/reactor.py
@@ -795,6 +795,7 @@ def rebuild_db():
     inary.api.set_userinterface(ui)
     inary.api.set_options(options)
     inary.api.set_scom(scom)
+    ctx.filesdb.create_filesdb()
 
 def calculate_conflicts(*args, **kw):
     return inary.conflict.calculate_conflicts(*args, **kw)
